# Task 6: Рефакторинг-гейт после каждого блока

## Goal
Обязательная проверка качества архитектуры после каждой крупной фичи.

## Context
Нужен устойчивый процесс, чтобы не терять модульность по мере роста механик.

## Key Steps
1. После каждой задачи (#1-#5) проводить мини-ревью зависимостей модулей.
2. Проверять границы: нет ли прямых зависимостей UI -> Enemy internals и т.п.
3. Фиксировать найденный технический долг в `.Doc/Issues.md`.
4. Выполнять точечный рефакторинг до старта следующего крупного блока.
5. Обновлять архитектурный документ при изменении контрактов.

## Blockers & Risks
- Давление сроков и пропуск refactor stage.
- Рост "временных" решений, которые остаются навсегда.

## Acceptance Criteria
- Каждый завершенный блок имеет запись о проверке модульности.
- Переход к следующему блоку только после закрытия критичных связностей.

## Notes
Это процессная задача, идет параллельно всем крупным блокам.

## Refactor Gate Report (for blocks #1-#5, 2026-02-17)

### Проведенные проверки
1. Границы модулей:
   - UI не зависит от внутренних структур EnemySystem.
   - Bootstrap работает через контракты (`I*System`), а не через concrete coupling.
2. Контроль связности:
   - Централизация lifecycle (`StartLevel`, `StopSession`, `GameCompleted`) сохранена.
   - Интеграционный контракт не требует внешних singleton.
3. Технический риск:
   - Основной hotspot: рост сложности `MiniGameBootstrap`.

### Выполненный рефакторинг
1. `MiniGameBootstrap`:
   - Выделено внутреннее состояние сессии в `SessionTelemetry` (combo/accuracy/avg response/difficulty).
   - Убрано дублирование логики подсчета и reset метрик.
   - Введен единый `EndGame(bool isWin)` для завершения раунда.
   - Снижен размер "бизнес-куска" в `OnAnswerSelected`.
2. Поведение не изменено функционально:
   - Core loop, combo reset, win/lose и результат интеграции сохранены.

### Валидация
- `dotnet build Assembly-CSharp.csproj` -> Success, 0 errors.

### Остаточный долг (некритичный, отложен в #7/#8)
- Визуальный слой пока в том же bootstrap-контексте (лазер/robot marker), будет вынесен в presentation adapters.
- `OnGUI` UI останется временным до ввода полноценного UI-skin pipeline.
